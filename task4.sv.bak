

module task4(input logic CLOCK_50, input logic [3:0] KEY, input logic [9:0] SW,
             output logic [6:0] HEX0, output logic [6:0] HEX1, output logic [6:0] HEX2,
             output logic [6:0] HEX3, output logic [6:0] HEX4, output logic [6:0] HEX5,
             output logic [9:0] LEDR);

    logic rst_n;
    assign rst_n = KEY[3];

    logic [7:0] ct_addr;
    logic [7:0] ct_rddata;

    logic crack_en;
    logic crack_rdy;
    logic [23:0] crack_key;
    logic crack_key_valid;

    logic started;

    always_ff @(posedge CLOCK_50) begin
        if(!rst_n)begin
            crack_en <= 1'b0;
        end
        else begin
            crack_en <= crack_rdy;
        end
    end




    ct_mem ct(
        .address(ct_addr),
        .clock(CLOCK_50),
        .data(8'd0),
        .wren(1'b0),
        .q(ct_rddata)
    );

    crack c(
        .clk(CLOCK_50),
        .rst_n(rst_n),
        .en(crack_en),
        .rdy(crack_rdy),
        .key(crack_key),
        .key_valid(crack_key_valid),
        .ct_addr(ct_addr),
        .ct_rddata(ct_rddata)
    );

    logic [3:0] h0, h1, h2, h3, h4, h5;

    assign h0 = crack_key[3:0];
    assign h1 = crack_key [7:4];
    assign h2 = crack_key [11:8];
    assign h3 = crack_key [15:12];
    assign h4 = crack_key [19:16];
    assign h5 = crack_key [23:20];

    seg7 display_pcard1(.SW(h0), .HEX0(HEX0));
    seg7 display_pcard2(.SW(h1), .HEX0(HEX1));
    seg7 display_pcard3(.SW(h2), .HEX0(HEX2));
    seg7 display_dcard1(.SW(h3), .HEX0(HEX3));
    seg7 display_dcard2(.SW(h4), .HEX0(HEX4));
    seg7 display_dcard3(.SW(h5), .HEX0(HEX5));

    assign LEDR[0] = crack_key_valid;

        


endmodule: task4
